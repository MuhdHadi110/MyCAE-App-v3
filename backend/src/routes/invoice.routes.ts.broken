import { Router, Response } from 'express';
import { AppDataSource } from '../config/database';
import { Raw } from 'typeorm';
import { Invoice, InvoiceStatus } from '../entities/Invoice';
import { ActivityType } from '../entities/Activity';
import { Project, ProjectStatus } from '../entities/Project';
import { User, UserRole } from '../entities/User';
import { PurchaseOrder } from '../entities/PurchaseOrder';
import { authenticate, AuthRequest, authorize } from '../middleware/auth';
import { body, validationResult } from 'express-validator';
import { InvoicePDFService } from '../services/invoice-pdf.service';
import { ActivityService } from '../services/activity.service';
import emailService from '../services/email.service';
import { upload, generateFileUrl } from '../utils/fileUpload';
import path from 'path';
import fs from 'fs';
import { logger } from '../utils/logger';

const router = Router();

// All invoice routes require authentication
router.use(authenticate);

/**
 * GET /api/invoices/next-number
 * Get the next available invoice number
 */
router.get('/next-number', async (req: AuthRequest, res: Response) => {
  try {
    const invoiceRepo = AppDataSource.getRepository(Invoice);

    // Find the highest invoice number
    const lastInvoice = await invoiceRepo
      .createQueryBuilder('invoice')
      .orderBy('invoice.invoice_number', 'DESC')
      .limit(1)
      .getOne();

    let nextNumber = 'MCE1548'; // Starting number after Excel import

    if (lastInvoice) {
      // Extract number from "MCE####" format
      const match = lastInvoice.invoice_number.match(/MCE(\d+)/);
      if (match) {
        const currentNum = parseInt(match[1]);
        nextNumber = `MCE${currentNum + 1}`;
      }
    }

    res.json({ nextNumber });
  } catch (error: any) {
    logger.error('Error getting next invoice number', { error });
    res.status(500).json({ error: 'Failed to get next invoice number' });
  }
});

/**
 * GET /api/invoices/project/:projectCode/context
 * Get invoice context for a project (previous invoices, percentages, sequence, total value)
 */
router.get('/project/:projectCode/context', async (req: AuthRequest, res: Response) => {
  try {
    const { projectCode } = req.params;
    const invoiceRepo = AppDataSource.getRepository(Invoice);
    const poRepo = AppDataSource.getRepository(PurchaseOrder);

    // Get all invoices for this project
    const invoices = await invoiceRepo
      .createQueryBuilder('invoice')
      .where('invoice.project_code LIKE :code', { code: `%${projectCode}%` })
      .orderBy('invoice.invoice_sequence', 'ASC')
      .getMany();

    // Calculate invoice totals
    const totalInvoiced = invoices.reduce((sum, inv) => sum + Number(inv.percentage_of_total), 0);
    const remainingPercentage = Math.max(0, 100 - totalInvoiced);
    const nextSequence = invoices.length + 1;

    // Get project total value from Purchase Orders
    const activePOs = await poRepo
      .createQueryBuilder('po')
      .where('po.project_code LIKE :code', { code: `%${projectCode}%` })
      .andWhere('po.is_active = true')
      .getMany();

    const projectTotalValue = activePOs.reduce((sum, po) =>
      sum + Number(po.effective_amount_myr || po.amount_myr || 0), 0
    );

    // Format previous invoices
    const previousInvoices = invoices.map(inv => ({
      invoiceNumber: inv.invoice_number,
      amount: Number(inv.amount),
      percentage: Number(inv.percentage_of_total),
      status: inv.status,
      date: inv.invoice_date,
    }));

    res.json({
      previousInvoices,
      totalInvoiced: Math.round(totalInvoiced * 100) / 100,
      remainingPercentage: Math.round(remainingPercentage * 100) / 100,
      nextSequence,
      projectTotalValue: Math.round(projectTotalValue * 100) / 100,
    });
  } catch (error: any) {
    logger.error('Error fetching invoice context', { error });
    res.status(500).json({ error: 'Failed to fetch invoice context' });
  }
});

/**
 * GET /api/invoices
 * Get all invoices with filters
 */
router.get('/', async (req: AuthRequest, res: Response) => {
  try {
    const { status, project_code, limit = 100, offset = 0 } = req.query;
    const invoiceRepo = AppDataSource.getRepository(Invoice);

    let query = invoiceRepo
      .createQueryBuilder('invoice')
      .leftJoinAndSelect('invoice.project', 'project')
      .orderBy('invoice.invoice_date', 'DESC');

    if (status) {
      query = query.where('invoice.status = :status', { status });
    }

    if (project_code) {
      query = query.andWhere('invoice.project_code LIKE :code', { code: `%${project_code}%` });
    }

    const [invoices, total] = await query
      .take(parseInt(limit as string))
      .skip(parseInt(offset as string))
      .getManyAndCount();

    res.json({
      data: invoices,
      total,
      limit: parseInt(limit as string),
      offset: parseInt(offset as string),
    });
  } catch (error: any) {
    logger.error('Error fetching invoices', { error });
    res.status(500).json({ error: 'Failed to fetch invoices' });
  }
});

/**
 * GET /api/invoices/:id
 * Get single invoice
 */
router.get('/:id', async (req: AuthRequest, res: Response) => {
  try {
    const invoiceRepo = AppDataSource.getRepository(Invoice);
    const invoice = await invoiceRepo.findOne({
      where: { id: req.params.id },
      relations: ['project'],
    });

    if (!invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    res.json(invoice);
  } catch (error: any) {
    logger.error('Error fetching invoice', { error });
    res.status(500).json({ error: 'Failed to fetch invoice' });
  }
});

/**
 * POST /api/invoices
 * Create new invoice with automatic sequence, cumulative percentage, and project completion
 */
router.post(
  '/',
  [
    body('invoice_number').notEmpty().withMessage('Invoice number is required'),
    body('project_code').notEmpty().withMessage('Project code is required'),
    body('project_name').notEmpty().withMessage('Project name is required'),
    body('amount').isNumeric().withMessage('Amount must be a number'),
    body('issue_date').isISO8601().withMessage('Valid issue date is required'),
    body('percentage_of_total').isNumeric().withMessage('Percentage must be a number'),
  ],
  async (req: AuthRequest, res: Response) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const {
        invoice_number,
        project_code,
        project_name,
        amount,
        issue_date,
        due_date,
        percentage_of_total,
        description,
        remark,
        status = InvoiceStatus.DRAFT,
        file_url,
      } = req.body;

      const invoiceRepo = AppDataSource.getRepository(Invoice);
      const projectRepo = AppDataSource.getRepository(Project);

      // Validate project code is not empty after trimming
      if (!project_code || project_code.trim() === '') {
        return res.status(400).json({
          error: 'Project code is required and cannot be empty'
        });
      }

      // Check if invoice number already exists
      const existingInvoice = await invoiceRepo.findOne({ where: { invoice_number: invoice_number } });
      if (existingInvoice) {
        return res.status(400).json({ error: 'Invoice with this number already exists' });
      }

      // Get existing invoices for this project to calculate sequence and cumulative
      const existingInvoices = await invoiceRepo
        .createQueryBuilder('invoice')
        .where('invoice.project_code LIKE :code', { code: `%${project_code}%` })
        .getMany();

      const invoiceSequence = existingInvoices.length + 1;
      const previousTotal = existingInvoices.reduce((sum, inv) => sum + Number(inv.percentage_of_total), 0);
      const cumulativePercentage = previousTotal + Number(percentage_of_total);

      // Create the invoice
      const invoice = invoiceRepo.create({
        invoice_number,
        project_code,
        project_name,
        amount: parseFloat(amount),
        invoice_date: new Date(issue_date),
        percentage_of_total: parseFloat(percentage_of_total),
        invoice_sequence: invoiceSequence,
        cumulative_percentage: cumulativePercentage,
        remark,
        status: status as InvoiceStatus,
        file_url,
        created_by: req.user!.id,
      });

      const savedInvoice = await invoiceRepo.save(invoice);

      // Log invoice creation (wrapped in try-catch to prevent activity logging from breaking invoice creation)
      try {
        await ActivityService.logInvoiceCreate(req.user!.id, savedInvoice);
      } catch (activityError) {
        logger.error('Failed to log invoice creation activity', { error: activityError });
        // Continue with invoice creation even if activity logging fails
      }

      // Check if project should be marked as completed (100% invoiced)
      let projectCompleted = false;
      if (cumulativePercentage >= 100) {
        // Extract first project code (in case of multiple like "J22006, J22007")
        const primaryProjectCode = project_code.split(',')[0].trim();
        const project = await projectRepo.findOne({ where: { project_code: primaryProjectCode } });

        if (project && project.status !== ProjectStatus.COMPLETED) {
          logger.info('Project status updated to completed', { projectCode: primaryProjectCode, reason: '100% invoiced' });
          project.status = ProjectStatus.COMPLETED;
          await projectRepo.save(project);
          projectCompleted = true;
          logger.info('Project marked as completed', { projectCode: primaryProjectCode });
        }
      }

      res.status(201).json({
        message: 'Invoice created successfully',
        data: savedInvoice,
        projectCompleted,
        cumulativePercentage: Math.round(cumulativePercentage * 100) / 100,
      });
    } catch (error: any) {
      logger.error('Error creating invoice', { error });
      res.status(500).json({ error: 'Failed to create invoice' });
    }
  }
);

/**
 * PUT /api/invoices/:id
 * Update invoice
 */
router.put('/:id', 
  authorize(UserRole.ADMIN, UserRole.MANAGING_DIRECTOR, UserRole.MANAGER, UserRole.SENIOR_ENGINEER),
  [
    body('invoiceNumber').optional().notEmpty().withMessage('Invoice number is required'),
    body('amount').optional().isNumeric().withMessage('Amount must be a number'),
    body('percentageOfTotal').optional().isNumeric().withMessage('Percentage must be a number'),
    body('invoiceDate').optional().isISO8601().withMessage('Valid invoice date is required'),
    body('status').optional().isIn(Object.values(InvoiceStatus)).withMessage('Invalid status'),
    body('remark').optional().isString().withMessage('Remark must be text'),
  ],
  async (req: AuthRequest, res: Response) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const invoiceRepo = AppDataSource.getRepository(Invoice);
    const invoice = await invoiceRepo.findOne({
      where: { id: req.params.id },
      relations: ['project'],
    });

    if (!invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    // Status-based edit restrictions
    if (invoice.status === InvoiceStatus.APPROVED || invoice.status === InvoiceStatus.SENT) {
      return res.status(403).json({
        error: `Cannot edit ${invoice.status} invoices`
      });
    }

    if (invoice.status === InvoiceStatus.PENDING_APPROVAL) {
      // Only creator can edit pending invoices
      if (invoice.created_by !== req.user!.id && !req.user?.roles.includes(UserRole.ADMIN)) {
        return res.status(403).json({
          error: 'Only the invoice creator can edit invoices pending approval'
        });
      }
    }

    // Prevent editing paid invoices (except for admin)
    if (invoice.status === InvoiceStatus.PAID && !req.user?.roles.includes(UserRole.ADMIN)) {
      return res.status(403).json({ error: 'Paid invoices cannot be edited' });
    }

    // Store original values for audit logging
    const originalValues = { ...invoice };

    const {
      invoiceNumber,
      projectName,
      amount,
      invoiceDate,
      percentageOfTotal,
      remark,
      status,
      fileUrl,
    } = req.body;

    // Update fields if provided
    if (invoiceNumber !== undefined) invoice.invoice_number = invoiceNumber;
    if (projectName !== undefined) invoice.project_name = projectName;
    if (amount !== undefined) invoice.amount = parseFloat(amount);
    if (invoiceDate !== undefined) invoice.invoice_date = new Date(invoiceDate);
    if (percentageOfTotal !== undefined) {
      // Recalculate cumulative if percentage changed
      const existingInvoices = await invoiceRepo
        .createQueryBuilder('invoice')
        .where('invoice.project_code LIKE :code', { code: `%${invoice.project_code}%` })
        .andWhere('invoice.id != :id', { id: invoice.id })
        .getMany();

      const previousTotal = existingInvoices.reduce((sum, inv) => sum + Number(inv.percentage_of_total), 0);
      invoice.percentage_of_total = parseFloat(percentageOfTotal);
      invoice.cumulative_percentage = previousTotal + parseFloat(percentageOfTotal);
    }
    if (remark !== undefined) invoice.remark = remark;
    if (status !== undefined) invoice.status = status as InvoiceStatus;
    if (fileUrl !== undefined) invoice.file_url = fileUrl;

    const updatedInvoice = await invoiceRepo.save(invoice);

    // Log the changes for audit trail
    await ActivityService.logInvoiceUpdate(
      req.user!.id,
      originalValues,
      req.body,
      updatedInvoice
    );

    res.json({
      message: 'Invoice updated successfully',
      data: updatedInvoice,
    });
  } catch (error: any) {
    logger.error('Error updating invoice', { error });
    res.status(500).json({ error: 'Failed to update invoice' });
  }
});

/**
 * DELETE /api/invoices/:id
 * Delete invoice
 * Authorization: Senior Engineer and above
 */
router.delete('/:id',
  authorize(UserRole.SENIOR_ENGINEER, UserRole.PRINCIPAL_ENGINEER, UserRole.MANAGER, UserRole.MANAGING_DIRECTOR, UserRole.ADMIN),
  async (req: AuthRequest, res: Response) => {
  try {
    const invoiceRepo = AppDataSource.getRepository(Invoice);
    const invoice = await invoiceRepo.findOne({ where: { id: req.params.id } });

    if (!invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    await invoiceRepo.remove(invoice);

    res.json({ message: 'Invoice deleted successfully' });
  } catch (error: any) {
    logger.error('Error deleting invoice', { error });
    res.status(500).json({ error: 'Failed to delete invoice' });
  }
});

/**
 * POST /api/invoices/:id/submit-for-approval
 * Submit invoice for approval (Draft → Pending Approval)
 */
router.post('/:id/submit-for-approval',
  authorize(UserRole.SENIOR_ENGINEER, UserRole.PRINCIPAL_ENGINEER, UserRole.MANAGER, UserRole.MANAGING_DIRECTOR, UserRole.ADMIN),
  async (req: AuthRequest, res: Response) => {
    try {
      const invoiceRepo = AppDataSource.getRepository(Invoice);
      const invoice = await invoiceRepo.findOne({ where: { id: req.params.id } });

      if (!invoice) {
        return res.status(404).json({ error: 'Invoice not found' });
      }

      // Verify invoice is in draft status
      if (invoice.status !== InvoiceStatus.DRAFT) {
        return res.status(400).json({
          error: `Invoice must be in Draft status to submit for approval. Current status: ${invoice.status}`
        });
      }

      // Store original for audit logging (deep copy to prevent mutation)
      const originalStatus = invoice.status;
      const originalValues = { ...invoice };

      // Update status and track submission
      invoice.status = InvoiceStatus.PENDING_APPROVAL;
      invoice.submitted_for_approval_at = new Date();

      const updatedInvoice = await invoiceRepo.save(invoice);

      // Log activity with proper original values
      try {
        await ActivityService.logInvoiceUpdate(
          req.user!.id,
          { ...originalValues, status: originalStatus },
          { status: InvoiceStatus.PENDING_APPROVAL },
          updatedInvoice
        );
        } catch (activityError) {
        logger.error('Activity logging failed', { error: activityError });
        // Don't fail the request if activity logging fails
      }

      // Fetch all Managing Directors
      const userRepo = AppDataSource.getRepository(User);
      const mds = await userRepo.createQueryBuilder('user')
        .where(`JSON_CONTAINS(user.roles, '"managing-director"')`)
        .getMany();

      // Format date/time
      const submittedDate = invoice.submitted_for_approval_at!.toLocaleDateString('en-MY', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      const submittedTime = invoice.submitted_for_approval_at!.toLocaleTimeString('en-MY', {
        hour: '2-digit',
        minute: '2-digit'
      });

      // Send approval request email to all MDs (don't fail request if email fails)
      try {
        await emailService.sendInvoiceApprovalRequest(
          invoice.id,
          mds,
          invoice.invoice_number,
          invoice.amount,
          invoice.currency,
          invoice.project_code,
          invoice.project_name,
          req.user!.name,
          req.user!.email,
          submittedDate,
          submittedTime
        );
      } catch (emailError: any) {
        logger.error('Failed to send invoice approval notification', { error: emailError.message });
        // Don't fail the request if email fails
      }

      res.json({
        message: 'Invoice submitted for approval',
        data: updatedInvoice,
      });
    } catch (error: any) {
      logger.error('Error submitting invoice for approval', { error });
      res.status(500).json({ error: 'Failed to submit invoice for approval' });
    }
  }
);

/**
 * POST /api/invoices/:id/approve
 * Approve invoice (Pending Approval → Approved)
 * Authorization: MANAGING_DIRECTOR or ADMIN only
 */
router.post('/:id/approve',
  authorize(UserRole.MANAGING_DIRECTOR, UserRole.ADMIN),
  async (req: AuthRequest, res: Response) => {
    try {
      const invoiceRepo = AppDataSource.getRepository(Invoice);
      const invoice = await invoiceRepo.findOne({ where: { id: req.params.id } });

      if (!invoice) {
        return res.status(404).json({ error: 'Invoice not found' });
      }

      // Verify invoice is pending approval
      if (invoice.status !== InvoiceStatus.PENDING_APPROVAL) {
        return res.status(400).json({
          error: `Invoice must be pending approval to approve. Current status: ${invoice.status}`
        });
      }

      // Store original for audit logging
      const originalStatus = invoice.status;
      const originalValues = { ...invoice };

      // Update status and track approval
      invoice.status = InvoiceStatus.APPROVED;
      invoice.approved_by = req.user!.id;
      invoice.approved_at = new Date();

      const updatedInvoice = await invoiceRepo.save(invoice);

      // Log activity with proper original values
      try {
        await ActivityService.logInvoiceUpdate(
          req.user!.id,
          { ...originalValues, status: originalStatus },
          { status: InvoiceStatus.APPROVED, approved_by: req.user!.id },
          updatedInvoice
        );
      } catch (activityError) {
        console.error('Activity logging failed:', activityError);
        // Don't fail the request if activity logging fails
      }

      // Fetch creator
      const userRepo = AppDataSource.getRepository(User);
      const creator = await userRepo.findOne({ where: { id: invoice.created_by } });

      // Format date/time
      const approvedDate = invoice.approved_at!.toLocaleDateString('en-MY', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      const approvedTime = invoice.approved_at!.toLocaleTimeString('en-MY', {
        hour: '2-digit',
        minute: '2-digit'
      });

      // Send approval confirmation to creator
      await emailService.sendInvoiceApprovalConfirmation(
        invoice.id,
        creator!.email,
        creator!.name,
        invoice.invoice_number,
        invoice.amount,
        invoice.currency,
        invoice.project_code,
        invoice.project_name,
        req.user!.name,
        approvedDate,
        approvedTime
      ).catch(err => {
        logger.error('Failed to send approval confirmation email', { error: err.message });
      });

      res.json({
        message: 'Invoice approved successfully',
        data: updatedInvoice,
      });
    } catch (error: any) {
      logger.error('Error approving invoice', { error });
      res.status(500).json({ error: 'Failed to approve invoice' });
    }
  }
);

/**
 * POST /api/invoices/:id/withdraw
 * Withdraw invoice from approval (Pending Approval → Draft)
 * Authorization: Creator only
 */
router.post('/:id/withdraw',
  authorize(UserRole.ADMIN, UserRole.MANAGING_DIRECTOR, UserRole.MANAGER, UserRole.SENIOR_ENGINEER, UserRole.PRINCIPAL_ENGINEER, UserRole.ENGINEER),
  async (req: AuthRequest, res: Response) => {
    try {
      const invoiceRepo = AppDataSource.getRepository(Invoice);
      const invoice = await invoiceRepo.findOne({ where: { id: req.params.id } });

      if (!invoice) {
        return res.status(404).json({ error: 'Invoice not found' });
      }

      // Verify invoice is pending approval
      if (invoice.status !== InvoiceStatus.PENDING_APPROVAL) {
        return res.status(400).json({
          error: `Invoice must be pending approval to withdraw. Current status: ${invoice.status}`
        });
      }

      // Verify user is the creator
      if (invoice.created_by !== req.user!.id && !req.user?.roles.includes(UserRole.ADMIN)) {
        return res.status(403).json({
          error: 'Only the invoice creator can withdraw from approval'
        });
      }

      // Store original for audit logging
      const originalStatus = invoice.status;
      const originalValues = { ...invoice };

      // Update status and clear submission tracking
      invoice.status = InvoiceStatus.DRAFT;
      invoice.submitted_for_approval_at = undefined as any;

      const updatedInvoice = await invoiceRepo.save(invoice);

      // Log activity with proper original values
      try {
        await ActivityService.logInvoiceUpdate(
          req.user!.id,
          { ...originalValues, status: originalStatus },
          { status: InvoiceStatus.DRAFT },
          updatedInvoice
        );
      } catch (activityError) {
        console.error('Activity logging failed:', activityError);
        // Don't fail the request if activity logging fails
      }

      // Fetch all Managing Directors
      const userRepo = AppDataSource.getRepository(User);
      const mds = await userRepo.createQueryBuilder('user')
        .where(`JSON_CONTAINS(user.roles, '"managing-director"')`)
        .getMany();

      // Format date/time
      const withdrawnDate = new Date().toLocaleDateString('en-MY', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      const withdrawnTime = new Date().toLocaleTimeString('en-MY', {
        hour: '2-digit',
        minute: '2-digit'
      });

      // Send withdrawal notification to all MDs
      await emailService.sendInvoiceWithdrawnNotification(
        invoice.id,
        mds,
        invoice.invoice_number,
        invoice.amount,
        invoice.currency,
        invoice.project_code,
        invoice.project_name,
        req.user!.name,
        withdrawnDate,
        withdrawnTime
      ).catch(err => {
        logger.error('Failed to send invoice withdrawal notification', { error: err.message });
      });

      res.json({
        message: 'Invoice withdrawn from approval',
        data: updatedInvoice,
      });
    } catch (error: any) {
      logger.error('Error withdrawing invoice', { error });
      res.status(500).json({ error: 'Failed to withdraw invoice from approval' });
    }
  }
);

/**
 * POST /api/invoices/:id/mark-as-sent
 * Mark invoice as sent (Approved → Sent)
 */
router.post('/:id/mark-as-sent',
  authorize(UserRole.SENIOR_ENGINEER, UserRole.PRINCIPAL_ENGINEER, UserRole.MANAGER, UserRole.MANAGING_DIRECTOR, UserRole.ADMIN),
  async (req: AuthRequest, res: Response) => {
    try {
      const invoiceRepo = AppDataSource.getRepository(Invoice);
      const invoice = await invoiceRepo.findOne({ where: { id: req.params.id } });

      if (!invoice) {
        return res.status(404).json({ error: 'Invoice not found' });
      }

      // Verify invoice is approved
      if (invoice.status !== InvoiceStatus.APPROVED) {
        return res.status(400).json({
          error: `Invoice must be approved to mark as sent. Current status: ${invoice.status}`
        });
      }

      // Store original for audit logging
      const originalValues = { ...invoice };

      // Update status
      invoice.status = InvoiceStatus.SENT;

      const updatedInvoice = await invoiceRepo.save(invoice);

      // Log activity
      await ActivityService.logInvoiceUpdate(
        req.user!.id,
        originalValues,
        { status: InvoiceStatus.SENT },
        updatedInvoice
      );

      res.json({
        message: 'Invoice marked as sent',
        data: updatedInvoice,
      });
    } catch (error: any) {
      logger.error('Error marking invoice as sent', { error });
      res.status(500).json({ error: 'Failed to mark invoice as sent' });
    }
  }
);

/**
 * POST /api/invoices/:id/mark-as-paid
 * Mark invoice as paid (Sent → Paid)
 */
router.post('/:id/mark-as-paid',
  authorize(UserRole.ADMIN, UserRole.MANAGING_DIRECTOR, UserRole.MANAGER, UserRole.PRINCIPAL_ENGINEER),
  async (req: AuthRequest, res: Response) => {
    try {
      const invoiceRepo = AppDataSource.getRepository(Invoice);
      const invoice = await invoiceRepo.findOne({ where: { id: req.params.id } });

      if (!invoice) {
        return res.status(404).json({ error: 'Invoice not found' });
      }

      // Only sent invoices can be marked as paid
      if (invoice.status !== InvoiceStatus.SENT) {
        return res.status(400).json({
          error: `Invoice must be sent to mark as paid. Current status: ${invoice.status}`
        });
      }

      // Update status to paid
      invoice.status = InvoiceStatus.PAID;
      const updatedInvoice = await invoiceRepo.save(invoice);

      // Log activity
      await ActivityService.log({
        userId: req.user!.id,
        type: ActivityType.INVOICE_STATUS_CHANGE,
        description: `Invoice ${invoice.invoice_number} marked as paid`,
        entityType: 'invoice',
        entityId: invoice.id,
        module: 'finance',
        details: JSON.stringify({
          invoiceNumber: invoice.invoice_number,
          from: invoice.status,
          to: 'paid',
        }),
      });

      res.json({
        message: 'Invoice marked as paid',
        data: updatedInvoice,
      });
    } catch (error: any) {
      logger.error('Error marking invoice as paid', { error });
      res.status(500).json({ error: 'Failed to mark invoice as paid' });
    }
  }
);

/**
 * POST /api/invoices/:id/upload
 * Upload invoice document file
 */
router.post(
  '/:id/upload',
  authorize(UserRole.SENIOR_ENGINEER, UserRole.PRINCIPAL_ENGINEER, UserRole.MANAGER, UserRole.MANAGING_DIRECTOR, UserRole.ADMIN),
  upload.single('file'),
  async (req: AuthRequest, res: Response) => {
    try {
      const { id } = req.params;
      const invoiceRepo = AppDataSource.getRepository(Invoice);

      // Check if invoice exists
      const invoice = await invoiceRepo.findOne({ where: { id } });
      if (!invoice) {
        return res.status(404).json({ error: 'Invoice not found' });
      }

      if (!req.file) {
        return res.status(400).json({ error: 'No file uploaded' });
      }

      // Generate file URL
      const fileUrl = generateFileUrl(req.file.filename, req);

      // Update invoice with file URL
      await invoiceRepo.update(id, { file_url: fileUrl });

      res.status(200).json({
        message: 'File uploaded successfully',
        fileUrl,
        filename: req.file.filename,
      });
    } catch (error: any) {
      logger.error('Error uploading invoice file', { error });
      res.status(500).json({ error: error.message || 'Failed to upload file' });
    }
  }
);

/**
 * GET /api/invoices/:id/pdf
 * View uploaded invoice document (or generate PDF if no file uploaded)
 */
router.get('/:id/pdf', async (req: AuthRequest, res: Response) => {
  try {
    logger.debug('Fetching document for invoice', { invoiceId: req.params.id });

    const invoiceRepo = AppDataSource.getRepository(Invoice);
    const invoice = await invoiceRepo.findOne({ where: { id: req.params.id } });

    if (!invoice) {
      logger.debug('Invoice not found', { invoiceId: req.params.id });
      return res.status(404).json({ error: 'Invoice not found' });
    }

    // Check if uploaded file exists
    if (invoice.file_url) {
      logger.debug('Serving uploaded document', { fileUrl: invoice.file_url });

      // Extract filename from URL (handle both relative and absolute URLs)
      let filename = path.basename(invoice.file_url);

      // Handle URLs like "/uploads/filename.pdf" or "http://domain/uploads/filename.pdf"
      if (invoice.file_url.includes('/uploads/')) {
        const parts = invoice.file_url.split('/uploads/');
        filename = parts[parts.length - 1];
      }

      // SECURITY: Validate filename to prevent path traversal attacks
      // Only allow alphanumeric characters, hyphens, underscores, and dots
      const safeFilenamePattern = /^[a-zA-Z0-9_\-]+\.[a-zA-Z0-9]+$/;
      if (!safeFilenamePattern.test(filename)) {
        logger.error('Invalid filename detected', { filename });
        return res.status(400).json({ error: 'Invalid filename format' });
      }

      const uploadsDir = path.join(__dirname, '../../uploads');
      const filePath = path.join(uploadsDir, filename);

      // SECURITY: Ensure resolved path is within uploads directory
      const resolvedPath = path.resolve(filePath);
      const resolvedUploadsDir = path.resolve(uploadsDir);
      if (!resolvedPath.startsWith(resolvedUploadsDir)) {
        logger.error('Path traversal attempt detected', {
          filename,
          resolvedPath,
          resolvedUploadsDir
        });
        return res.status(403).json({ error: 'Access denied' });
      }

      logger.debug('Resolved file path', {
        fileUrl: invoice.file_url,
        filename,
        uploadsDir,
        fullPath: filePath,
        exists: fs.existsSync(filePath)
      });

      // Check if file exists
      if (!fs.existsSync(filePath)) {
        logger.error('Uploaded file not found on disk', {
          filePath,
          uploadsDir,
          filesInDir: fs.existsSync(uploadsDir) ? fs.readdirSync(uploadsDir).length : 0
        });
        return res.status(404).json({
          error: 'Document file not found on server',
          details: `Looking for: ${filename}`
        });
      }

      // Set headers and send file
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `inline; filename="invoice-${invoice.invoice_number}.pdf"`);

      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
    } else {
      // No file uploaded - return error message
      logger.debug('No document uploaded for invoice', { invoiceNumber: invoice.invoice_number });
      return res.status(404).json({ error: 'No document uploaded for this invoice' });
    }

      // SECURITY: Validate filename to prevent path traversal attacks
      // Only allow alphanumeric characters, hyphens, underscores, and dots
      const safeFilenamePattern = /^[a-zA-Z0-9_\-]+\.[a-zA-Z0-9]+$/;
      if (!safeFilenamePattern.test(filename)) {
        logger.error('Invalid filename detected', { filename });
        return res.status(400).json({ error: 'Invalid filename format' });
      }

      const uploadsDir = path.join(__dirname, '../../uploads');
      const filePath = path.join(uploadsDir, filename);

      // SECURITY: Ensure the resolved path is within the uploads directory
      const resolvedPath = path.resolve(filePath);
      const resolvedUploadsDir = path.resolve(uploadsDir);
      if (!resolvedPath.startsWith(resolvedUploadsDir)) {
        return res.status(403).json({ error: 'Access denied' });
      }

      logger.debug('Resolved file path', {
        fileUrl: invoice.file_url,
        filename,
        uploadsDir,
        fullPath: filePath,
        exists: fs.existsSync(filePath)
      });
      // Check if file exists
      if (!fs.existsSync(filePath)) {
        logger.error('Uploaded file not found on disk', {
          filePath,
          uploadsDir,
          filesInDir: fs.existsSync(uploadsDir) ? fs.readdirSync(uploadsDir).length : 0
        });
        return res.status(404).json({
          error: 'Document file not found on server',
          details: `Looking for: ${filename}`
        });
      }

      // Set headers and send file
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `inline; filename="invoice-${invoice.invoice_number}.pdf"`);

      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
    } else {
      // No file uploaded - return error message
      logger.debug('No document uploaded for invoice', { invoiceNumber: invoice.invoice_number });
      return res.status(404).json({ error: 'No document uploaded for this invoice' });
    }
  } catch (error: any) {
    logger.error('Error serving invoice document', {
      error: error.message,
      invoiceId: req.params.id
    });

    res.status(500).json({ error: `Failed to serve invoice document: ${error.message}` });
  }
});


/**
 * Debug endpoint to check company settings
 * Only available in development mode
 */
router.get('/debug-settings', async (req: AuthRequest, res: Response) => {
  // Only allow in development mode
  if (process.env.NODE_ENV === 'production') {
    return res.status(404).json({ error: 'Not found' });
  }

  try {
    const { CompanySettingsService } = await import('../services/companySettings.service');
    const settings = await CompanySettingsService.getSettings();
    
    res.json({
      success: true,
      settings: {
        company_name: settings.company_name,
        logo_url: settings.logo_url,
        logo_size: settings.logo_size,
        header_position: settings.header_position,
        page_margin: settings.        page_margin
      }
    });
  } catch (error: any) {
    logger.error('Settings debug failed', { error });
    res.status(500).json({ error: `Failed to load settings: ${error.message}` });
  }
});

/**
 * Test specific invoice PDF generation with size reporting
 * Only available in development mode
 */
router.get('/test-invoice-size/:invoiceId', async (req: AuthRequest, res: Response) => {
  // Only allow in development mode
  if (process.env.NODE_ENV === 'production') {
    return res.status(404).json({ error: 'Not found' });
  }
  try {
    const invoiceRepo = AppDataSource.getRepository(Invoice);
    const invoice = await invoiceRepo.findOne({ where: { id: req.params.invoiceId } });

    if (!invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    logger.debug('Testing PDF size for invoice', {
      id: invoice.id,
      invoiceNumber: invoice.invoice_number,
      amount: invoice.amount
    });

    const pdfBuffer = await InvoicePDFService.generateInvoicePDF(invoice);

    if (!pdfBuffer) {
      return res.status(500).json({ error: 'Failed to generate PDF' });
    }

    const sizeKB = pdfBuffer.length / 1024;
    const sizeMB = (pdfBuffer.length / (1024 * 1024)).toFixed(2);

    logger.debug('PDF Size Analysis', {
      invoiceId: invoice.id,
      invoiceNumber: invoice.invoice_number,
      amount: invoice.amount,
      sizeBytes: pdfBuffer.length,
      sizeKB: parseFloat(sizeKB.toFixed(2)),
      sizeMB: parseFloat(sizeMB),
      recommendedViewer: parseFloat(sizeMB) > 1.0 ? 'Browser Viewer Recommended' : 'React-PDF Should Work'
    });

    res.json({
      success: true,
      analysis: {
        invoiceId: invoice.id,
        invoiceNumber: invoice.invoice_number,
        amount: invoice.amount,
        sizeBytes: pdfBuffer.length,
        sizeKB: sizeKB.toFixed(2),
        sizeMB: sizeMB,
        recommendedViewer: parseFloat(sizeMB) > 1.0 ? 'Browser Viewer Recommended' : 'React-PDF Should Work'
      }
    });

  } catch (error: any) {
    logger.error('Invoice size test failed', { error });
    res.status(500).json({ error: `Failed to test invoice: ${error.message}` });
  }
});

export default router;
